; Listing generated by Microsoft (R) Optimizing Compiler Version 19.33.31631.0 

	TITLE	C:\Users\Puhaa\Downloads\Demo6\Demo6\SysCore\Kernel\Debug\DebugDisplay.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?tbuf@@3PADA					; tbuf
PUBLIC	?bchars@@3PADA					; bchars
_BSS	SEGMENT
?tbuf@@3PADA DB	020H DUP (?)				; tbuf
_BSS	ENDS
_DATA	SEGMENT
?bchars@@3PADA DB 030H					; bchars
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
_DATA	ENDS
PUBLIC	?DebugClrScr@@YAXG@Z				; DebugClrScr
PUBLIC	?DebugPuts@@YAXPAD@Z				; DebugPuts
PUBLIC	?DebugPrintf@@YAHPBDZZ				; DebugPrintf
PUBLIC	?DebugSetColor@@YAII@Z				; DebugSetColor
PUBLIC	?DebugGotoXY@@YAXII@Z				; DebugGotoXY
PUBLIC	?DebugPutc@@YAXE@Z				; DebugPutc
PUBLIC	?itoa@@YAXIIPAD@Z				; itoa
PUBLIC	?itoa_s@@YAXHIPAD@Z				; itoa_s
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
_BSS	SEGMENT
?_xPos@@3IA DD	01H DUP (?)				; _xPos
?_yPos@@3IA DD	01H DUP (?)				; _yPos
?_startX@@3IA DD 01H DUP (?)				; _startX
?_startY@@3IA DD 01H DUP (?)				; _startY
?_color@@3IA DD	01H DUP (?)				; _color
_BSS	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Puhaa\Downloads\Demo6\Demo6\SysCore\Kernel\DebugDisplay.cpp
;	COMDAT ?itoa_s@@YAXHIPAD@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_buf$ = 16						; size = 4
?itoa_s@@YAXHIPAD@Z PROC				; itoa_s, COMDAT

; 107  :    if (base > 16) return;

	mov	ecx, DWORD PTR _base$[esp-4]
	cmp	ecx, 16					; 00000010H
	ja	SHORT $LN5@itoa_s

; 108  :    if (i < 0) {

	push	ebx
	mov	ebx, DWORD PTR _i$[esp]
	push	edi
	mov	edi, DWORD PTR _buf$[esp+4]
	test	ebx, ebx
	jns	SHORT $LN3@itoa_s

; 109  :       *buf++ = '-';

	mov	BYTE PTR [edi], 45			; 0000002dH
	inc	edi

; 110  :       i *= -1;

	neg	ebx
$LN3@itoa_s:
	push	ebp

; 84   :    int pos = 0;

	xor	ebp, ebp

; 85   :    int opos = 0;
; 86   :    int top = 0;
; 87   : 
; 88   :    if (i == 0 || base > 16) {

	test	ebx, ebx
	je	SHORT $LN12@itoa_s
	push	esi
$LL6@itoa_s:

; 90   :       buf[1] = '\0';
; 91   :       return;
; 92   :    }
; 93   : 
; 94   :    while (i != 0) {
; 95   :       tbuf[pos] = bchars[i % base];

	xor	edx, edx
	lea	esi, DWORD PTR ?tbuf@@3PADA[ebp]
	mov	eax, ebx

; 96   :       pos++;

	inc	ebp
	div	ecx

; 97   :       i /= base;

	mov	eax, ebx
	mov	cl, BYTE PTR ?bchars@@3PADA[edx]
	xor	edx, edx
	mov	BYTE PTR [esi], cl
	mov	ecx, DWORD PTR _base$[esp+12]
	div	ecx
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL6@itoa_s

; 98   :    }
; 99   :    top=pos--;
; 100  :    for (opos=0; opos<top; pos--,opos++) {

	test	ebp, ebp
	jle	SHORT $LN9@itoa_s
	npad	2
$LL10@itoa_s:

; 101  :       buf[opos] = tbuf[pos];

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi-1]
	mov	BYTE PTR [eax+edi], cl
	inc	eax
	cmp	eax, ebp
	jl	SHORT $LL10@itoa_s
$LN9@itoa_s:

; 102  :    }
; 103  :    buf[opos] = 0;

	pop	esi
	pop	ebp
	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	ebx

; 111  :    }
; 112  :    itoa(i,base,buf);
; 113  : }

	ret	0
$LN12@itoa_s:
	pop	ebp

; 89   :       buf[0] = '0';

	mov	WORD PTR [edi], 48			; 00000030H
	pop	edi
	pop	ebx
$LN5@itoa_s:

; 111  :    }
; 112  :    itoa(i,base,buf);
; 113  : }

	ret	0
?itoa_s@@YAXHIPAD@Z ENDP				; itoa_s
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Puhaa\Downloads\Demo6\Demo6\SysCore\Kernel\DebugDisplay.cpp
;	COMDAT ?itoa@@YAXIIPAD@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_buf$ = 16						; size = 4
?itoa@@YAXIIPAD@Z PROC					; itoa, COMDAT

; 83   : void itoa(unsigned i,unsigned base,char* buf) {

	push	ebx

; 84   :    int pos = 0;
; 85   :    int opos = 0;
; 86   :    int top = 0;
; 87   : 
; 88   :    if (i == 0 || base > 16) {

	mov	ebx, DWORD PTR _i$[esp]
	push	ebp
	push	edi
	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN8@itoa
	mov	ebp, DWORD PTR _base$[esp+8]
	cmp	ebp, 16					; 00000010H
	ja	SHORT $LN8@itoa
	push	esi
	npad	9
$LL2@itoa:

; 90   :       buf[1] = '\0';
; 91   :       return;
; 92   :    }
; 93   : 
; 94   :    while (i != 0) {
; 95   :       tbuf[pos] = bchars[i % base];

	xor	edx, edx
	lea	esi, DWORD PTR ?tbuf@@3PADA[edi]
	mov	eax, ebx

; 96   :       pos++;

	inc	edi
	div	ebp

; 97   :       i /= base;

	mov	eax, ebx
	mov	cl, BYTE PTR ?bchars@@3PADA[edx]
	xor	edx, edx
	div	ebp
	mov	BYTE PTR [esi], cl
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL2@itoa

; 98   :    }
; 99   :    top=pos--;
; 100  :    for (opos=0; opos<top; pos--,opos++) {

	mov	edx, DWORD PTR _buf$[esp+12]
	test	edi, edi
	jle	SHORT $LN5@itoa
	npad	7
$LL6@itoa:

; 101  :       buf[opos] = tbuf[pos];

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi-1]
	mov	BYTE PTR [eax+edx], cl
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL6@itoa
$LN5@itoa:

; 102  :    }
; 103  :    buf[opos] = 0;

	pop	esi
	pop	edi

; 104  : }

	pop	ebp
	mov	BYTE PTR [eax+edx], 0
	pop	ebx
	ret	0
$LN8@itoa:

; 89   :       buf[0] = '0';

	mov	eax, DWORD PTR _buf$[esp+8]
	pop	edi

; 104  : }

	pop	ebp
	pop	ebx
	mov	WORD PTR [eax], 48			; 00000030H
	ret	0
?itoa@@YAXIIPAD@Z ENDP					; itoa
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Puhaa\Downloads\Demo6\Demo6\SysCore\Kernel\DebugDisplay.cpp
;	COMDAT ?DebugPutc@@YAXE@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?DebugPutc@@YAXE@Z PROC					; DebugPutc, COMDAT

; 58   : 
; 59   : 	if (c==0)

	mov	dl, BYTE PTR _c$[esp-4]
	test	dl, dl
	je	SHORT $LN1@DebugPutc

; 60   : 		return;
; 61   : 
; 62   : 	if (c == '\n'||c=='\r') {	/* start new line */

	cmp	dl, 10					; 0000000aH
	je	SHORT $LN4@DebugPutc
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN4@DebugPutc

; 65   : 		return;
; 66   : 	}
; 67   : 
; 68   : 	if (_xPos > 79) {			/* start new line */

	push	esi
	mov	esi, DWORD PTR ?_xPos@@3IA
	cmp	esi, 79					; 0000004fH
	jbe	SHORT $LN5@DebugPutc

; 69   : 		_yPos+=2;
; 70   : 		_xPos=_startX;

	mov	eax, DWORD PTR ?_startX@@3IA
	add	DWORD PTR ?_yPos@@3IA, 2
	mov	DWORD PTR ?_xPos@@3IA, eax
	pop	esi
$LN1@DebugPutc:

; 78   : }

	ret	0
$LN5@DebugPutc:

; 71   : 		return;
; 72   : 	}
; 73   : 
; 74   : 	/* draw the character */
; 75   : 	unsigned char* p = (unsigned char*)VID_MEMORY + (_xPos++)*2 + _yPos * 80;

	mov	eax, DWORD PTR ?_yPos@@3IA
	lea	eax, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [esi+eax*8]

; 76   : 	*p++ = c;
; 77   : 	*p =_color;

	mov	al, BYTE PTR ?_color@@3IA
	inc	esi
	mov	BYTE PTR [ecx*2+753664], dl
	mov	DWORD PTR ?_xPos@@3IA, esi
	mov	BYTE PTR [ecx*2+753665], al
	pop	esi

; 78   : }

	ret	0
$LN4@DebugPutc:

; 63   : 		_yPos+=2;
; 64   : 		_xPos=_startX;

	mov	eax, DWORD PTR ?_startX@@3IA
	add	DWORD PTR ?_yPos@@3IA, 2
	mov	DWORD PTR ?_xPos@@3IA, eax

; 78   : }

	ret	0
?DebugPutc@@YAXE@Z ENDP					; DebugPutc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Puhaa\Downloads\Demo6\Demo6\SysCore\Kernel\DebugDisplay.cpp
;	COMDAT ?DebugGotoXY@@YAXII@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?DebugGotoXY@@YAXII@Z PROC				; DebugGotoXY, COMDAT

; 127  : 
; 128  : 	// reposition starting vectors for next text to follow
; 129  : 	// multiply by 2 do to the video modes 2byte per character layout
; 130  : 	_xPos = x*2;

	mov	eax, DWORD PTR _x$[esp-4]
	lea	ecx, DWORD PTR [eax+eax]

; 131  : 	_yPos = y*2;

	mov	eax, DWORD PTR _y$[esp-4]
	add	eax, eax
	mov	DWORD PTR ?_xPos@@3IA, ecx
	mov	DWORD PTR ?_yPos@@3IA, eax

; 132  : 	_startX=_xPos;

	mov	DWORD PTR ?_startX@@3IA, ecx

; 133  : 	_startY=_yPos;

	mov	DWORD PTR ?_startY@@3IA, eax

; 134  : }

	ret	0
?DebugGotoXY@@YAXII@Z ENDP				; DebugGotoXY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Puhaa\Downloads\Demo6\Demo6\SysCore\Kernel\DebugDisplay.cpp
;	COMDAT ?DebugSetColor@@YAII@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?DebugSetColor@@YAII@Z PROC				; DebugSetColor, COMDAT

; 120  : 
; 121  : 	unsigned t=_color;

	mov	eax, DWORD PTR ?_color@@3IA

; 122  : 	_color=c;

	mov	ecx, DWORD PTR _c$[esp-4]
	mov	DWORD PTR ?_color@@3IA, ecx

; 123  : 	return t;
; 124  : }

	ret	0
?DebugSetColor@@YAII@Z ENDP				; DebugSetColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Puhaa\Downloads\Demo6\Demo6\SysCore\Kernel\DebugDisplay.cpp
;	COMDAT ?DebugPrintf@@YAHPBDZZ
_TEXT	SEGMENT
_str$1 = -96						; size = 32
_str$2 = -64						; size = 32
_str$3 = -32						; size = 32
_str$ = 8						; size = 4
?DebugPrintf@@YAHPBDZZ PROC				; DebugPrintf, COMDAT

; 159  : int DebugPrintf (const char* str, ...) {

	sub	esp, 96					; 00000060H
	push	edi
	mov	edi, DWORD PTR _str$[esp+96]

; 160  : 
; 161  : 	if(!str)

	test	edi, edi
	jne	SHORT $LN9@DebugPrint

; 162  : 		return 0;

	xor	eax, eax
	pop	edi

; 224  : 				break;
; 225  : 		}
; 226  : 
; 227  : 	}
; 228  : 
; 229  : 	va_end (args);
; 230  : }

	add	esp, 96					; 00000060H
	ret	0
$LN9@DebugPrint:
	push	esi

; 166  : 
; 167  : 	for (size_t i=0; i<strlen(str);i++) {

	push	edi
	xor	esi, esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	test	eax, eax
	je	$LN26@DebugPrint

; 163  : 
; 164  : 	va_list		args;
; 165  : 	va_start (args, str);

	push	ebx
	lea	ebx, DWORD PTR _str$[esp+104]
	npad	4
$LL4@DebugPrint:

; 168  : 
; 169  : 		switch (str[i]) {

	mov	al, BYTE PTR [esi+edi]
	cmp	al, 37					; 00000025H
	je	SHORT $LN10@DebugPrint

; 218  : 				}
; 219  : 
; 220  : 				break;
; 221  : 
; 222  : 			default:
; 223  : 				DebugPutc (str[i]);

	push	eax
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	add	esp, 4
	jmp	$LN2@DebugPrint
$LN10@DebugPrint:

; 170  : 
; 171  : 			case '%':
; 172  : 
; 173  : 				switch (str[i+1]) {

	movsx	eax, BYTE PTR [esi+edi+1]
	sub	eax, 88					; 00000058H
	cmp	eax, 32					; 00000020H
	ja	$LN17@DebugPrint
	movzx	eax, BYTE PTR $LN24@DebugPrint[eax]
	jmp	DWORD PTR $LN25@DebugPrint[eax*4]
$LN11@DebugPrint:

; 174  : 
; 175  : 					/*** characters ***/
; 176  : 					case 'c': {
; 177  : 						char c = va_arg (args, char);
; 178  : 						DebugPutc (c);

	movzx	eax, BYTE PTR [ebx+4]
	add	ebx, 4
	push	eax
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	add	esp, 4

; 179  : 						i++;		// go to next character
; 180  : 						break;

	jmp	SHORT $LN28@DebugPrint
$LN12@DebugPrint:

; 181  : 					}
; 182  : 
; 183  : 					/*** address of ***/
; 184  : 					case 's': {
; 185  : 						int c = (int&) va_arg (args, char);
; 186  : 						char str[32]={0};
; 187  : 						itoa_s (c, 16, str);

	lea	eax, DWORD PTR _str$1[esp+108]
	add	ebx, 4
	push	eax
	xorps	xmm0, xmm0
	push	16					; 00000010H
	push	DWORD PTR [ebx]
	movups	XMMWORD PTR _str$1[esp+120], xmm0
	movups	XMMWORD PTR _str$1[esp+136], xmm0
	call	?itoa_s@@YAXHIPAD@Z			; itoa_s

; 188  : 						DebugPuts (str);

	lea	eax, DWORD PTR _str$1[esp+120]

; 189  : 						i++;		// go to next character
; 190  : 						break;

	jmp	SHORT $LN29@DebugPrint
$LN13@DebugPrint:

; 191  : 					}
; 192  : 
; 193  : 					/*** integers ***/
; 194  : 					case 'd':
; 195  : 					case 'i': {
; 196  : 						int c = va_arg (args, int);
; 197  : 						char str[32]={0};
; 198  : 						itoa_s (c, 10, str);

	lea	eax, DWORD PTR _str$2[esp+108]
	add	ebx, 4
	push	eax
	xorps	xmm0, xmm0
	push	10					; 0000000aH
	push	DWORD PTR [ebx]
	movups	XMMWORD PTR _str$2[esp+120], xmm0
	movups	XMMWORD PTR _str$2[esp+136], xmm0
	call	?itoa_s@@YAXHIPAD@Z			; itoa_s

; 199  : 						DebugPuts (str);

	lea	eax, DWORD PTR _str$2[esp+120]

; 200  : 						i++;		// go to next character
; 201  : 						break;

	jmp	SHORT $LN29@DebugPrint
$LN15@DebugPrint:

; 202  : 					}
; 203  : 
; 204  : 					/*** display in hex ***/
; 205  : 					case 'X':
; 206  : 					case 'x': {
; 207  : 						int c = va_arg (args, int);
; 208  : 						char str[32]={0};
; 209  : 						itoa_s (c,16,str);

	lea	eax, DWORD PTR _str$3[esp+108]
	add	ebx, 4
	push	eax
	xorps	xmm0, xmm0
	push	16					; 00000010H
	push	DWORD PTR [ebx]
	movups	XMMWORD PTR _str$3[esp+120], xmm0
	movups	XMMWORD PTR _str$3[esp+136], xmm0
	call	?itoa_s@@YAXHIPAD@Z			; itoa_s

; 210  : 						DebugPuts (str);

	lea	eax, DWORD PTR _str$3[esp+120]
$LN29@DebugPrint:

; 166  : 
; 167  : 	for (size_t i=0; i<strlen(str);i++) {

	push	eax
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 16					; 00000010H
$LN28@DebugPrint:
	inc	esi
$LN2@DebugPrint:
	push	edi
	inc	esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	esi, eax
	jb	$LL4@DebugPrint
	pop	ebx
	pop	esi
	pop	edi

; 224  : 				break;
; 225  : 		}
; 226  : 
; 227  : 	}
; 228  : 
; 229  : 	va_end (args);
; 230  : }

	add	esp, 96					; 00000060H
	ret	0
$LN17@DebugPrint:

; 211  : 						i++;		// go to next character
; 212  : 						break;
; 213  : 					}
; 214  : 
; 215  : 					default:
; 216  : 						va_end (args);
; 217  : 						return 1;

	mov	eax, 1
	pop	ebx
$LN26@DebugPrint:
	pop	esi
	pop	edi

; 224  : 				break;
; 225  : 		}
; 226  : 
; 227  : 	}
; 228  : 
; 229  : 	va_end (args);
; 230  : }

	add	esp, 96					; 00000060H
	ret	0
	npad	1
$LN25@DebugPrint:
	DD	$LN15@DebugPrint
	DD	$LN11@DebugPrint
	DD	$LN13@DebugPrint
	DD	$LN12@DebugPrint
	DD	$LN17@DebugPrint
$LN24@DebugPrint:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
?DebugPrintf@@YAHPBDZZ ENDP				; DebugPrintf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Puhaa\Downloads\Demo6\Demo6\SysCore\Kernel\DebugDisplay.cpp
;	COMDAT ?DebugPuts@@YAXPAD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?DebugPuts@@YAXPAD@Z PROC				; DebugPuts, COMDAT

; 150  : void DebugPuts (char* str) {

	push	edi

; 151  : 
; 152  : 	if (!str)

	mov	edi, DWORD PTR _str$[esp]
	test	edi, edi
	je	SHORT $LN3@DebugPuts

; 153  : 		return;
; 154  : 
; 155  : 	for (size_t i=0; i<strlen (str); i++)

	push	esi
	push	edi
	xor	esi, esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@DebugPuts
	npad	7
$LL4@DebugPuts:

; 156  : 		DebugPutc (str[i]);

	mov	al, BYTE PTR [esi+edi]

; 59   : 	if (c==0)

	test	al, al
	je	SHORT $LN2@DebugPuts

; 60   : 		return;
; 61   : 
; 62   : 	if (c == '\n'||c=='\r') {	/* start new line */

	cmp	al, 10					; 0000000aH
	je	SHORT $LN10@DebugPuts
	cmp	al, 13					; 0000000dH
	je	SHORT $LN10@DebugPuts

; 63   : 		_yPos+=2;
; 64   : 		_xPos=_startX;
; 65   : 		return;
; 66   : 	}
; 67   : 
; 68   : 	if (_xPos > 79) {			/* start new line */

	mov	edx, DWORD PTR ?_xPos@@3IA
	cmp	edx, 79					; 0000004fH
	ja	SHORT $LN10@DebugPuts

; 69   : 		_yPos+=2;
; 70   : 		_xPos=_startX;
; 71   : 		return;
; 72   : 	}
; 73   : 
; 74   : 	/* draw the character */
; 75   : 	unsigned char* p = (unsigned char*)VID_MEMORY + (_xPos++)*2 + _yPos * 80;

	mov	ecx, DWORD PTR ?_yPos@@3IA
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [edx+ecx*8]
	inc	edx

; 76   : 	*p++ = c;

	mov	BYTE PTR [ecx*2+753664], al

; 77   : 	*p =_color;

	mov	al, BYTE PTR ?_color@@3IA
	mov	DWORD PTR ?_xPos@@3IA, edx
	mov	BYTE PTR [ecx*2+753665], al
	jmp	SHORT $LN2@DebugPuts
$LN10@DebugPuts:

; 153  : 		return;
; 154  : 
; 155  : 	for (size_t i=0; i<strlen (str); i++)

	mov	eax, DWORD PTR ?_startX@@3IA
	add	DWORD PTR ?_yPos@@3IA, 2
	mov	DWORD PTR ?_xPos@@3IA, eax
$LN2@DebugPuts:
	push	edi
	inc	esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	esi, eax
	jb	SHORT $LL4@DebugPuts
$LN17@DebugPuts:
	pop	esi
$LN3@DebugPuts:
	pop	edi

; 157  : }

	ret	0
?DebugPuts@@YAXPAD@Z ENDP				; DebugPuts
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Puhaa\Downloads\Demo6\Demo6\SysCore\Kernel\DebugDisplay.cpp
;	COMDAT ?DebugClrScr@@YAXG@Z
_TEXT	SEGMENT
_c$ = 8							; size = 2
?DebugClrScr@@YAXG@Z PROC				; DebugClrScr, COMDAT

; 136  : void DebugClrScr (const unsigned short c) {

	mov	dl, BYTE PTR _c$[esp-4]

; 137  : 
; 138  : 	unsigned char* p = (unsigned char*)VID_MEMORY;

	mov	eax, 753665				; 000b8001H
	mov	ecx, 2400				; 00000960H
	npad	2
$LL4@DebugClrSc:

; 139  : 
; 140  : 	for (int i=0; i<160*30; i+=2) {
; 141  : 
; 142  : 		p[i] = ' ';  /* Need to watch out for MSVC++ optomization memset() call */

	mov	BYTE PTR [eax-1], 32			; 00000020H
	lea	eax, DWORD PTR [eax+2]

; 143  : 		p[i+1] = c;

	mov	BYTE PTR [eax-2], dl
	sub	ecx, 1
	jne	SHORT $LL4@DebugClrSc

; 144  : 	}
; 145  : 
; 146  : 	// go to start of previous set vector
; 147  : 	_xPos=_startX;_yPos=_startY;

	mov	eax, DWORD PTR ?_startX@@3IA
	mov	DWORD PTR ?_xPos@@3IA, eax
	mov	eax, DWORD PTR ?_startY@@3IA
	mov	DWORD PTR ?_yPos@@3IA, eax

; 148  : }

	ret	0
?DebugClrScr@@YAXG@Z ENDP				; DebugClrScr
_TEXT	ENDS
END
